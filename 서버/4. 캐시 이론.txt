컴퓨터 구조 원리 : 캐시

예시
직원들을 이제 잘 움직이고 사용을 하는데 이제는 조금 다른 문제가 생겼는데 손님들이 굉장히 많이 몰려오다 보니까 일처리를 어떻게 할지 고민이 시작
주문을 받는 직원이 하나 있는데 주방에 어떤 식으로든 전달을 해야지만 주문이 들어가겠죠
주문 현황에 기입을하면 주방에서 확인을 하고 일을 시작을 한다.

하지만 주문 현황판이 너무 멀리에 있어서 왔다 갔다 하는게 너무 시간이 아깝다는 문제가 있다.
이를 해결하기 위한 꼼수를 생각을 한다
꼼수는 테이블을 돌아다니다가 머리에다가 최대한 기억을 한다음 현환판에 가서 주문을 넣는것이다.
이렇게 작업을 하면 장점이 하나더 있는데 중간에 주문을 변경해달라고 하면 현황판에 주문이 들어가 있으면 취소를 하고 여러문제가 있는데
그냥 내가 처리하면 되기 때문에 빠르게 처리가 가능하다.

하지만 직원이 여러명이게 되면 문제가 생기기 된다.
1번 알바가 주문을 받아 또 다른 테이블을 돌아다니고 있었는데 2번 알바한테 아까 주문 했던거에서 변경사항을 이야기하면 혼선이 벌어지게 된다.

- cpu 정리
코어를 확대해서 까보면은 ALU라는 연산을 하는 장치가 있고 그리고 기억을 하는 용도로 사용하는 캐시 장치가 또 있다.
코어는 이런 식으로 세트라고 보면 되고 연산과 기억이 세트로 있는데 최종적으로 메모리에 기입을 하는거는 멀리 떨어져 있기 때문에 매번 메로리 갱신이 일어난다고 해서 이렇게 램에 가가지고 뭔가 데이터를 갱신하는 것은 너무나도 비효율적이다. 
그래서 아까 단기 기억과 더 큰 기억을 요구할 수 있는 메모장을 이용해 가지고 뭔가를 계속 기억하고 있는데 얘도 마찬가지로 단계별로 맨위 단계에는 레지스터라는 애가 있고
L1,L2캐시이런식으로 다양한 캐시 기능을 하는 그런 기억 장치들이 하나씩 준비되어있다.

그래서 결국에는 어떤 변수나 어떤 메모리 있는 값을 조작한다고 했을 때 그거는 바로 실제로 메모리다가 바꿔치기를 하는 게 아니라 일단은 캐시 장치에다가 기입을 해가지고 나중에 조금 시간이 지나면 그걸로 한 번에 메모리에다가 올리는 그런 작업을 하게 될 것.

- 캐시 철학
캐시를 두가지로 분류를 할수 있는데 temporal locality와 spacial locality로 구분을 한다.
tmeporal은 시간 관련이 있다는 것을 알 수가 있다.
가장 최근에 사용한 그 변수가 또 다시 재사용될 확률이 높다는 철학에서 온 것
spacial은 공간 관련이 있다
방금 접근한 그변수와 인접한 주소에 있는 그런 주소들이 또 방문될 것

다시 확인
스레드 마다 각각의 코어로 실행되고 있을 텐데 코어마다 자신만의 캐시가 따로 있고 변수를 고친다고 해서 무조건 메모리에다가 올라가는 그런게 아니니까 다른 스레드 입장에서 볼때는 수정이 되어 있지 않은 상태 였던 거이였다.
 











































