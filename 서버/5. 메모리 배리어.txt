하드웨어 최적화
컴퓨터가 멀티스레드를 사용하면 x = y = r1 = r2 = 0;라는 변수의 값을 초기화 하고 함수에서 값을 y = 1;r1 = x; 하나를 선언하고 x = 1;r2 = y; 이렇게 정의를 하면
원래는 r1,r2가 절대 0이 나올수 있는 상황이 아닌데 프로그램이 종료가 된다.
전에 배웠던 컴파일러의 문제인지 확인하기 위해서 vloatile라는 문법을 사용을 해도 같은 상황이 나타난다.
이유는 하드웨어도 우리를 위해서 최적화를 시켜주고 있는 상태이다.
이 코어 하나 입장에서 보면은 둘이 아무런 연관성일 없다고 판단하여 자기 멋대로 위치를 바꾸어서 실행을 해버려서 발생하는 문제이다

상황
메모장에 적어둔 것을 현황판에 커밋을 하고 다른 알바생은 다른 주문을 받기 전에 일단 한번 현황판을 커밋을 받은 상태로 일을 하는 것을 의미한다.
다른 사람이 동기화를 하고 실제로 사용할 사람은 일단 동기화를 먼저 한 다음에 그 다음에 리드를 해서 그 데이터를 불러 읽어 드려야 정상적인 방식으로 이제 똑같은 상황이 보이게 된다.

메모리 배리어
1. 코드 재배치 억제

Thread.MemoryBarrier(); 를사용하면 윗줄에 넘지 말라는 경계를 만들어 버린다.

메모리 배리어 종류
- 1. Full Memory Barrier : Store/Load 둘다 막는다.
- 2. Store Memory Barrier : Store만 막는다.
- 3. Load Memory Barrier : Load만 막는다.

2. 가시성
static vloatile int x =0;으로 가시성을 높인다.
Thread.MemoryBarrier();으로 가시성을 높인다.

그리고 한쪽만 Thread.MemoryBarrier();을 하지 말고 다른 쪽에서도 사용하기 위해서는 다른쪽 함수에서도 Thread.MemoryBarrier();똑같이 선언해줘라.

정리 
- 코드 재배치 억제와 가시성을 높인다.
















































