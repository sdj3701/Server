DeadLock 정리
한쪽이 사용하고 풀어주지 않고 나오면 DeadLock이 발생한다.
이러한 문제를 해결하기 위해서 lock을 사용해서 문제를 예방하는 방법이 있다.

좀더 고차원 적으로 문제가 발생할 수 있다.
자물쇠가 2개가 있는데 각각하나씩 가지고 있는데 사용하기 위해서는 두개의 자물쇠가 필요한데 서로 대기하는 상태가 발생한다.
서로 꼬리물기를 해서 문제가 생기는 것 처럼 문제가 발생

이것을 해결하기 위한 방법으로는 규칙을 정하면 된다.
자물쇠의 순서를 정해서 위쪽 자물쇠를 먼저 획득을 하면 먼저 사용하는 규칙을 정하면 된다.

예시
class가 여러개 있으면 각각의 object가 생성되어 lock을 가지게 되고 여러 클래스가 서로 방문해야하는 이유가 생기는데
1번 클래스에서 2번 클래스 함수를 부르는데 거기 함수에 lock이 걸려 있고 
2번 클래스에서 1번 클래스 함수를 부르는데 거기 함수에 lock이 걸려 있으면 서로 꼬이는 현상이 발생한다.

이런한 문제를 해결 방안으로는 시도를 하다가 오래 걸리면 그냥 포기하는 방법도 있다.
1. Monitor.TryEnter() 라는 함수를 사용는 방법이 있다.
tip) 루키즈는 일단 크래시를 발생시켜 콜스택을 추적하여 데드락이 일어났다는 것을 추론하는 것을 추천 방법이 있다.

그리고 발생하는 타이밍이 동시에 실행이 되어야만 데드락이 발생되는 것이다. 
그래서 Thread.Sleep(100); 만줘도 데드락이 발생하지 것을 볼 수 있다.

꼼수는 우리만의 락을 만들어 사용

결론
잘 구현한다고 대부분 경우에는 데드락을 완전히 막을 수는 없다.
데드락은 굉장히 생각보다 까다롭기 때문에 실제로 발생한 다음에 사실 고치는 게 더 쉽다.









































